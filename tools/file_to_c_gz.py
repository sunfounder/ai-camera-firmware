#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
将文件转换为C语言的gz二进制数据格式
输出格式：
//File: filename.gz, Size: size
#define filename_gz_len size
const uint8_t filename_gz[] PROGMEM = {
    0x00, 0x01, 0x02, ...
};
"""

WWW_DIR = "../ai-camera-firmware/www"
BUILD_DIR = "build"

import os
import gzip
from pathlib import Path


def file_to_c_gz(input_file, output_file=None, bytes_per_line=12):
    """
    将输入文件压缩并转换为C语言的gz二进制数据格式
    
    Args:
        input_file: 输入文件路径
        output_file: 输出文件路径，如果为None则输出到标准输出
        bytes_per_line: 每行显示的字节数
    """
    try:
        # 读取文件内容
        with open(input_file, 'rb') as f:
            file_content = f.read()
        
        # 压缩内容
        compressed_content = gzip.compress(file_content)
        compressed_size = len(compressed_content)
        
        # 获取文件名
        file_path = Path(input_file)
        original_name = file_path.name.split(".")
        # 创建GZ文件名
        gz_filename = f"{original_name}.gz"
        name = original_name[0]
        hash = None
        if len(original_name) == 3:
            hash = original_name[1]
            file_type = original_name[2]
        else:
            file_type = original_name[1]
        var_name = f"{name}_{file_type}_gz"

        # 生成C代码
        c_code = []
        c_code.append(f"// Generated by tools/compress_www/file_to_c_gz.py")
        c_code.append(f"// File: {gz_filename}, Size: {compressed_size}")
        if hash:
            c_code.append(f"#define {file_type.upper()}_HASH \"{hash}\"")
        c_code.append(f"#define {var_name}_len {compressed_size}")
        c_code.append(f"const uint8_t {var_name}[] PROGMEM = {{")
        
        # 格式化二进制数据
        hex_values = []
        for byte in compressed_content:
            hex_values.append(f"0x{byte:02x}")
        
        # 按行分割
        for i in range(0, len(hex_values), bytes_per_line):
            line_values = hex_values[i:i+bytes_per_line]
            c_code.append(f"    {', '.join(line_values)}{',' if i + bytes_per_line < len(hex_values) else ''}")
        
        c_code.append("};")
        
        # 组合成完整代码
        result = '\n'.join(c_code)
        
        # 输出结果
        if output_file:
            with open(output_file, 'w', encoding='utf-8') as f:
                f.write(result)
            print(f"已成功输出到文件: {output_file}")
        else:
            print(result)
        
        return True
        
    except Exception as e:
        print(f"处理文件时出错: {str(e)}")
        return False


def main():
    if not os.path.isdir(WWW_DIR):
        raise Exception(f"www目录不存在: {WWW_DIR}")
    if not os.path.isdir(BUILD_DIR):
        raise Exception(f"build目录不存在: {BUILD_DIR}")

    js_filename = ""
    js_out_file = os.path.join(WWW_DIR, "js.h")
    for file in os.listdir(os.path.join(BUILD_DIR, "static/js")):
        if file.endswith(".js"):
            js_filename = file
            js_in_file = os.path.join(BUILD_DIR, "static/js", file)
            break

    css_filename = ""
    css_out_file = os.path.join(WWW_DIR, "css.h")
    for file in os.listdir(os.path.join(BUILD_DIR, "static/css")):
        if file.endswith(".css"):
            css_filename = file
            css_in_file = os.path.join(BUILD_DIR, "static/css", file)
            break

    index_filename = ""
    index_out_file = os.path.join(WWW_DIR, "index.h")
    index_in_file = os.path.join(BUILD_DIR, "index.html")

    print(f"index_filename: {index_filename}")
    print(f"index_in_file: {index_in_file}")
    print(f"index_out_file: {index_out_file}")
    file_to_c_gz(index_in_file, output_file=index_out_file)

    print(f"css_filename: {css_filename}")
    print(f"css_in_file: {css_in_file}")
    print(f"css_out_file: {css_out_file}")
    file_to_c_gz(css_in_file, output_file=css_out_file)

    print(f"js_filename: {js_filename}")
    print(f"js_in_file: {js_in_file}")
    print(f"js_out_file: {js_out_file}")
    file_to_c_gz(js_in_file, output_file=js_out_file)


if __name__ == "__main__":
    main()